## Лабораторная работа 3  
**Интерполяция, аппроксимация и численное дифференцирование/интегрирование**

Третья лабораторная работа посвящена ряду классических задач прикладной математики:
- полиномиальная интерполяция (формулы Лагранжа и Ньютона) и выбор узлов для интерполяции;
- кубические сплайны естественного типа;
- метод наименьших квадратов (МНК) для аппроксимации экспериментальных данных;
- численное дифференцирование (первая и вторая производные) с использованием конечных разностей;
- численное интегрирование (методы прямоугольников, трапеций, Симпсона, формула Эйлера) и уточнение по методу Рунге–Ромберга.

Ниже кратко описана теория и то, как она используется в реализованных скриптах.

### 1. Интерполяция полиномом Ньютона / Лагранжа (`3lab/1/lagrange.js`)

Задана таблица узлов \((x_i,y_i)\) и точка \(x^\ast\), в которой требуется вычислить интерполяционный многочлен фиксированной степени. Вместо явной формулы Лагранжа
\[
  P_n(x) = \sum_{i=0}^{n} y_i \ell_i(x),\quad
  \ell_i(x) = \prod_{j\ne i}\frac{x-x_j}{x_i-x_j},
\]
используется форма Ньютона с разделёнными разностями:
\[
  P_n(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)(x-x_1) + \dots + a_n\prod_{j=0}^{n-1}(x-x_j),
\]
где коэффициенты \(a_k\) — разделённые разности \(f[x_0,\dots,x_k]\). В коде таблица разделённых разностей строится функцией `dividedDifferences`:

```48:61:3lab/1/lagrange.js
function dividedDifferences(X, Y) {
  const n = X.length;
  const table = Array(n).fill(0).map(() => Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    table[i][0] = Y[i];
  }
  for (let j = 1; j < n; j++) {
    for (let i = 0; i < n - j; i++) {
      table[i][j] = (table[i + 1][j - 1] - table[i][j - 1]) / (X[i + j] - X[i]);
    }
  }
  return table[0]; // a_0,...,a_n
}
```

Значение многочлена в точке \(x^\ast\) вычисляется по схеме Горнера для формы Ньютона:

```67:76:3lab/1/lagrange.js
function evaluateNewton(X, coeffs, x) {
  let result = coeffs[0];
  let product = 1;
  for (let i = 1; i < coeffs.length; i++) {
    product *= (x - X[i - 1]);
    result += coeffs[i] * product;
  }
  return result;
}
```

Особенность реализации — анализ **всех возможных последовательных интервалов** узлов заданной длины (для многочленов второй и третьей степени) и оценка интерполяционной погрешности в точке \(x^\ast\) через оценку максимальной разделённой разности (аналог оценки \(f^{(n+1)}\)). Это позволяет исследовать, как выбор интервала интерполяции влияет на качество аппроксимации.

### 2. Кубический сплайн естественного типа (`3lab/3/spline.js`)

В модуле `spline.js` строится **естественный кубический сплайн** дефекта 1 на сетке \(\{x_i\}_{i=0}^n\). На каждом отрезке \([x_i,x_{i+1}]\) сплайн задаётся полиномом:
\[
  S_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d_i(x-x_i)^3,
\]
с условиями:
- непрерывности \(S_i(x_i)=y_i\), \(S_i(x_{i+1})=y_{i+1}\);
- непрерывности первой и второй производных в узлах;
- естественной граничной условности \(S''(x_0)=S''(x_n)=0\).

Из этих условий получается трёхдиагональная СЛАУ на коэффициенты \(c_i\), которая строится в функции `buildNaturalCubicSpline`. Сначала вычисляются длины шагов \(h_i=x_{i+1}-x_i\) и правая часть \(\alpha_i\), затем составляется трёхдиагональная система для внутренних \(c_1,\dots,c_{n-1}\):

```39:60:3lab/3/spline.js
const h = Array(n).fill(0);
for (let i = 0; i < n; i++) {
  h[i] = X[i + 1] - X[i];
}
const alpha = Array(n).fill(0);
for (let i = 1; i < n; i++) {
  alpha[i] = (3 / h[i]) * (Y[i + 1] - Y[i]) - (3 / h[i - 1]) * (Y[i] - Y[i - 1]);
}
...
matrixB[i] = 2 * (h[i] + h[i + 1]);
matrixA[i] = h[i];
matrixC[i] = h[i + 1];
matrixD[i] = alpha[i + 1];
```

Система решается методом прогонки `solveTridiagonal`, а коэффициенты \(a_i, b_i, c_i, d_i\) для каждого отрезка восстанавливаются по стандартным формулам:

```78:83:3lab/3/spline.js
for (let i = 0; i < n; i++) {
  const ai = Y[i];
  const bi = (Y[i+1] - Y[i]) / h[i] - h[i]*(2*cCoeffs[i] + cCoeffs[i+1])/3;
  const ci = cCoeffs[i];
  const di = (cCoeffs[i+1] - cCoeffs[i]) / (3*h[i]);
  ...
}
```

Функция `evaluateSpline` реализует подстановку в соответствующий кусок сплайна. Отдельно проводится:
- поиск сегмента, содержащего \(x^\ast\);
- проверка интерполяции во всех узлах (\(S(x_i)\approx y_i\));
- вывод всех коэффициентов \(a_i,b_i,c_i,d_i\) и текстовой формулы отрезка, содержащего \(x^\ast\).

### 3. Метод наименьших квадратов (МНК) (`3lab/4/least_squares.js`)

Для заданных точек \((x_i,y_i)\) строятся многочлены степеней 1, 2 и 3, минимизирующие сумму квадратов отклонений:
\[
  \Phi(a_0,\dots,a_m) = \sum_{i} \bigl(y_i - P_m(x_i)\bigr)^2,\quad P_m(x) = \sum_{k=0}^m a_k x^k.
\]
Условия минимума приводят к **нормальной системе**:
\[
  \sum_{k=0}^m a_k \sum_i x_i^{j+k} = \sum_i y_i x_i^{j}, \quad j=0,\dots,m.
\]
В коде матрица нормальной системы и правая часть собираются в функции `leastSquares`:

```38:52:3lab/4/least_squares.js
const n = degree + 1;
const matrix = Array(n).fill(0).map(() => Array(n).fill(0));
const rightSide = Array(n).fill(0);
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) {
    const power = i + j;
    matrix[i][j] = X.reduce((sum, x) => sum + Math.pow(x, power), 0);
  }
}
for (let i = 0; i < n; i++) {
  rightSide[i] = X.reduce((sum, x, idx) => sum + Y[idx] * Math.pow(x, i), 0);
}
```

Далее система решается методом Гаусса `solveSLAU`, получая коэффициенты \(a_k\). Для каждой степени:
- строится аналитическое выражение многочлена `polynomialToString`;
- вычисляются сумма квадратов ошибок \(\Phi_m\) и среднеквадратичное отклонение;
- считается значение \(P_m(x^\ast)\) в заданной точке.

Итоговый вывод включает сравнительную таблицу \(\Phi_m, E_m, P_m(x^\ast)\) для трёх степеней, а также проверку значений многочленов в узлах и значения коэффициентов \(a_k\).

### 4. Численное дифференцирование (`3lab/5/numerical_differentiation.js`)

Рассматривается функция
\[
  y(x) = \frac{2\sin(2x) - 3\cos(3x)}{\sqrt{2x+3}},\quad x\in[-1,1],\quad h=0{,}1.
\]
Для неё выводится точная первая производная \(y'(x)\) аналитически (через правило дифференцирования дроби и производные тригонометрических и корневых функций) и вторая производная численно через высокоточное центральное дифференцирование. В коде:

```5:15:3lab/5/numerical_differentiation.js
function f(x) {
  return (2 * Math.sin(2 * x) - 3 * Math.cos(3 * x)) / Math.sqrt(2 * x + 3);
}
function fPrimeAnalytical(x) {
  const numerator = 2 * Math.sin(2 * x) - 3 * Math.cos(3 * x);
  const denominator = Math.sqrt(2 * x + 3);
  const numeratorPrime = 4 * Math.cos(2 * x) + 9 * Math.sin(3 * x);
  const denominatorPrime = 1 / Math.sqrt(2 * x + 3);
  return (numeratorPrime * denominator - numerator * denominatorPrime) / (denominator * denominator);
}
```

Реализован широкий набор конечных разностей:
- **первая производная**: односторонние схемы 2‑го порядка (правые/левые), центральная схема 2‑го порядка, правые/левые схемы 3‑точечные, центральная 4‑точечная;
- **вторая производная**: центральная 3‑точечная, правые/левые 3‑точечные, центральная 5‑точечная.

Например, центральная схема второго порядка для первой производной и 3‑точечная центральная схема для второй:

```30:48:3lab/5/numerical_differentiation.js
function firstDerivativeCentral2(f, x, h) {
  return (f(x + h) - f(x - h)) / (2 * h);
}
function secondDerivativeCentral3(f, x, h) {
  return (f(x + h) - 2 * f(x) + f(x - h)) / (h * h);
}
```

Функция `computeAllDerivatives` в каждой узловой точке проверяет применимость схем (особенно около концов интервала), вычисляет численные значения, сравнивает с аналитическими и сохраняет абсолютные ошибки. Затем:
- проводится сравнение для шага \(h\) и шага \(h/2\) по средней ошибке по всей сетке;
- строятся сводные таблицы для первой и второй производной;
- применяется формула Рунге–Ромберга
\[
  \Phi^\ast = \Phi_{h/2} + \frac{\Phi_{h/2}-\Phi_h}{2^p - 1},
\]
для уточнения центральных схем (с порядком \(p=2\) для базовых и \(p=4\) для более точных), что позволяет наглядно показать выигрыш в точности.

### 5. Численное интегрирование (`3lab/6/numerical_integration.js`)

Интегрируется та же функция
\[
  f(x) = \frac{\tan(x/2)+\ln(x+1)}{\cos^2(x-1)+1}
\]
на отрезке \([a,b]=[-0{,}5;1{,}5]\). Реализованы формулы:
- **метод средних прямоугольников**:
  \[
    I_h^{\text{mid}} = h \sum_{i=0}^{n-1} f\Bigl(a + \bigl(i+\tfrac{1}{2}\bigr)h\Bigr),
  \]
- **метод трапеций**:
  \[
    I_h^{\text{trap}} = h\left[\frac{f(a)+f(b)}{2} + \sum_{i=1}^{n-1} f(a+ih)\right],
  \]
- **метод Симпсона**:
  \[
    I_h^{\text{S}} = \frac{h}{3}\left[f(a)+f(b)+4\sum_{i\ \text{неч}} f(a+ih)+2\sum_{i\ \text{чёт}} f(a+ih)\right],
  \]
- **формула Эйлера** (правка результата трапеций с использованием приближённых производных в концах).

В коде эти схемы реализованы функциями `midpointMethod`, `trapezoidMethod`, `simpsonMethod`, `eulerMethod`. Для оценки «точного» значения используется Симпсон с очень малым шагом:

```5:8:3lab/6/numerical_integration.js
function exactIntegral() {
  const h = 0.00001;
  return simpsonMethod(f, -0.5, 1.5, h);
}
```

Для двух шагов \(h\) и \(h/2\) строится таблица значений каждого метода и их погрешностей относительно эталонного интеграла. Затем применяется **метод Рунге–Ромберга**:
\[
  I^\ast = I_{h/2} + \frac{I_{h/2} - I_h}{2^p - 1},
\]
где \(p\) — порядок точности метода (для трапеций и средних прямоугольников \(p=2\), для Симпсона \(p=4\)). Это позволяет получить уточнённые значения с существенно меньшей погрешностью и численно подтвердить порядок сходимости схем.

В отчёт выводятся:
- значения интегралов по различным методам при шагах \(h\) и \(h/2\);
- абсолютные погрешности;
- коэффициенты улучшения точности после применения Рунге–Ромберга.

### Итог

В лабораторной работе №3 на одном наборе экспериментальных данных и одной функции демонстрируется широкий спектр численных методов: **интерполяция (Ньютон/Лагранж), сплайновая аппроксимация, МНК, численное дифференцирование и интегрирование**, включая оценку и управление погрешностью (через анализ схем разностей и метод Рунге–Ромберга). Каждое задание снабжено подробным консольным выводом, что позволяет отследить, как теоретические формулы реализуются на практике и как ведут себя ошибки при сгущении сетки или увеличении порядка схем.


