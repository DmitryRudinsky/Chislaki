## Лабораторная работа 2  
**Численные методы решения нелинейных уравнений и систем нелинейных уравнений**

Во второй лабораторной работе реализуются и сравниваются классические численные методы решения:
- **одномерного нелинейного уравнения** \(f(x)=0\) (подзадача `2lab/1`);
- **системы двух нелинейных уравнений** \(F(x_1,x_2)=0\) (подзадача `2lab/2`).

Реализации сопровождаются автоматической проверкой условий сходимости, поиском интервалов изоляции корней и графическим анализом поведения функций (с использованием Electron и Plotly в файлах `electron-main.js`, `graph.js`, `index.html`).

### 1. Одномерное уравнение \(f(x) = 0\) (`2lab/1`)

В модуле `numerical_methods.js` задаётся скалярная функция
\[
  f(x) = x^4 - 5x^2 + 5\sin\frac{2x}{3} + 1,
\]
её первая и вторая производные:
\[
  f'(x) = 4x^3 - 10x + \frac{10}{3}\cos\frac{2x}{3},\qquad
  f''(x) = 12x^2 - 10 - \frac{20}{9}\sin\frac{2x}{3},
\]
что в коде реализовано функциями `f`, `df`, `d2f`:

```4:17:2lab/1/numerical_methods.js
function f(x) {
  return Math.pow(x, 4) - 5 * Math.pow(x, 2) + 5 * Math.sin(2 * x / 3) + 1;
}
function df(x) {
  return 4 * Math.pow(x, 3) - 10 * x + (10/3) * Math.cos(2 * x / 3);
}
function d2f(x) {
  return 12 * Math.pow(x, 2) - 10 - (20/9) * Math.sin(2 * x / 3);
}
```

Для решения уравнения реализованы следующие методы.

#### 1.1. Метод дихотомии (бисекции)

Метод дихотомии использует тот факт, что при непрерывной \(f(x)\) и смене знака на отрезке \([a,b]\) (\(f(a)f(b)<0\)) существует корень. Итерационная схема:
\[
  c_k = \frac{a_k + b_k}{2},\quad
  \text{если } f(a_k)f(c_k) < 0,\ \ b_{k+1}=c_k,\ a_{k+1}=a_k,\ 
  \text{иначе}\ a_{k+1}=c_k,\ b_{k+1}=b_k,
\]
с остановкой при \(|b_k-a_k|\le 2\varepsilon\) или \(|f(c_k)| < \varepsilon\). В коде это реализовано в `bisectionMethod`:

```19:39:2lab/1/numerical_methods.js
let c = (a + b) / 2;
while (Math.abs(b - a) > 2 * epsilon && iterations < maxIter) {
  c = (a + b) / 2;
  const fc = f(c);
  ...
  if (Math.abs(fc) < epsilon) break;
  if (f(a) * fc < 0) {
    b = c;
  } else {
    a = c;
  }
  iterations++;
}
```

#### 1.2. Метод Ньютона (касательных)

Метод Ньютона использует локальную линейную аппроксимацию:
\[
  x_{k+1} = x_k - \frac{f(x_k)}{f'(x_k)}.
\]
В дополнение к основной формуле в коде тщательно проверяются условия локальной сходимости:
- смена знака \(f(a)f(b)<0\);
- монотонность \(f'(x)\) на \([a,b]\) (\(f'(a)f'(b)>0\));
- сохранение знака второй производной \(f''(a)f''(b)>0\) (выпуклость или вогнутость);
- выбор начального приближения \(x_0\), удовлетворяющего \(f(x_0)f''(x_0) > 0\).

Фрагмент выбора \(x_0\) и итерационного процесса:

```107:125:2lab/1/numerical_methods.js
let x0;
const conditionA = fa * d2fa;
const conditionB = fb * d2fb;
...
if (conditionA > 0 && conditionB > 0) {
  x0 = Math.abs(fa) > Math.abs(fb) ? a : b;
} else if (conditionA > 0) {
  x0 = a;
} else if (conditionB > 0) {
  x0 = b;
} else {
  x0 = (a + b) / 2;
}
...
const xNew = x - fx / dfx;
if (Math.abs(xNew - x) < epsilon) { ... }
```

#### 1.3. Методы секущих и хорд

Метод секущих использует две последних точки \(x_{k-1},x_k\) и проводит через них секущую:
\[
  x_{k+1} = x_k - f(x_k)\frac{x_k - x_{k-1}}{f(x_k)-f(x_{k-1})}.
\]
Метод хорд (фиксированной секущей) удерживает один конец отрезка неподвижным (там, где \(f(x)f''(x)>0\)) и каждый раз проводит хорду к текущей точке:
\[
  x_{k+1} = x_{\text{moving}} - f(x_{\text{moving}})\frac{x_{\text{moving}} - x_{\text{fixed}}}{f(x_{\text{moving}})-f(x_{\text{fixed}})}.
\]
В функциях `secantMethod` и `chordMethod` эти формулы реализованы дословно, с детальной диагностикой начальных условий (`convergenceCheck`) и логом итераций (значения \(x_k\), \(f(x_k)\), длины шага).

#### 1.4. Метод простой итерации \(x=\varphi(x)\)

Для метода простой итерации уравнение приводится к виду
\[
  x = \varphi(x) = x - \lambda f(x),
\]
где параметр \(\lambda\) подбирается так, чтобы выполнялось условие сжатия \(\max_{x\in[a,b]}|\varphi'(x)| < 1\). В коде:
- оценивается диапазон \(f'(x)\) на \([a,b]\);
- вычисляется "оптимальное" \(\lambda = 2/(m+M)\) при знакопостоянстве производной;
- при необходимости \(\lambda\) уменьшается, пока \(\max|\varphi'(x)|<1\).
После этого выполняется итерация \(x_{k+1} = \varphi(x_k)\) с контролем выхода за разумные пределы:

```373:381:2lab/1/numerical_methods.js
function estimateMaxAbsDPhi(lambdaVal, left, right, n) {
  let maxVal = 0;
  for (let i = 0; i < n; i++) {
    const t = left + ((right - left) * i) / (n - 1);
    const val = Math.abs(1 - lambdaVal * df(t));
    if (val > maxVal) maxVal = val;
  }
  return maxVal;
}
...
while (iterations < maxIter) {
  const xNew = phi(x);
  if (Math.abs(xNew - x) > (b - a) * 100) { ... break; }
  ...
}
```

#### 1.5. Графический анализ и сводная таблица

В `graph.js` (и `index.html`) реализовано:
- построение графика произвольной функции \(f(x)\) по введённому выражению (через `eval` с подстановкой переменной `x`);
- автоматический поиск интервалов изоляции корней по критерию смены знака \(f(x_i)f(x_{i+1})<0\) с заданным шагом;
- заполнение полей ввода начальных приближений и интервалов для всех методов.

После вычислений функцией `solveAllMethods` формируется сводная таблица, где для каждого метода отображаются:
- полученный корень \(x\),
- число итераций,
- величина \(|f(x)|\),
- индикатор сходимости (✅ / ⚠️ / ❌).

### 2. Система двух нелинейных уравнений (`2lab/2`)

В подзадаче `2lab/2` рассматривается система
\[
  \begin{cases}
    x_1^2 + x_2^2 - 2\cos x_1 = 3,\\[4pt]
    e^{x_1^2-1} - x_2 = 3,
  \end{cases}
\]
то есть вектор-функция \(F(x) = (F_1(x_1,x_2), F_2(x_1,x_2))^\top\) задаётся как:

```1:12:2lab/2/numerical_methods.js
function F1(x1, x2) {
  return Math.pow(x1, 2) + Math.pow(x2, 2) - 2 * Math.cos(x1) - 3;
}
function F2(x1, x2) {
  return Math.exp(Math.pow(x1, 2) - 1) - x2 - 3;
}
```

Для численного решения используются:
- **метод Ньютона для систем**;
- **метод простой итерации с фиксированной (замороженной) обратной Якоби**;
- **метод Зейделя с замороженной обратной Якоби**.

#### 2.1. Метод Ньютона для системы

Метод Ньютона для системы в векторной форме:
\[
  x^{(k+1)} = x^{(k)} - J(x^{(k)})^{-1} F(x^{(k)}),
\]
где \(J(x)\) — матрица Якоби:
\[
  J(x_1,x_2) =
  \begin{pmatrix}
    \dfrac{\partial F_1}{\partial x_1} & \dfrac{\partial F_1}{\partial x_2}\\[4pt]
    \dfrac{\partial F_2}{\partial x_1} & \dfrac{\partial F_2}{\partial x_2}
  \end{pmatrix}
  =
  \begin{pmatrix}
    2x_1 + 2\sin x_1 & 2x_2\\
    2x_1 e^{x_1^2-1} & -1
  \end{pmatrix}.
\]
В коде эти частные производные и Якоби записаны в `jacobianMatrix`, а инверсия \(2\times2\) матрицы выполняется аналитически:

```31:55:2lab/2/numerical_methods.js
function jacobianMatrix(x1, x2) {
  return [
    [dF1_dx1(x1, x2), dF1_dx2(x1, x2)],
    [dF2_dx1(x1, x2), dF2_dx2(x1, x2)]
  ];
}
...
function inverse2x2(matrix) {
  const det = determinant2x2(matrix);
  if (Math.abs(det) < 1e-10) {
    return null;
  }
  return [
    [matrix[1][1] / det, -matrix[0][1] / det],
    [-matrix[1][0] / det, matrix[0][0] / det]
  ];
}
```

Итерация Ньютона для системы реализована в `newtonSystemMethod`, где для каждого шага:
- вычисляется \(F(x^{(k)})\) и \(\|F(x^{(k)})\|\);
- строится \(J(x^{(k)})\) и его обратная;
- считается приращение \(\Delta x = -J^{-1}F\);
- оценивается норма приращения и невязка как критерии остановки:

```82:110:2lab/2/numerical_methods.js
const F_vector = [f1, f2];
const F_norm = vectorNorm(F_vector);
...
const J = jacobianMatrix(x1, x2);
const J_inv = inverse2x2(J);
const delta = multiplyMatrixVector(J_inv, [-f1, -f2]);
const x1_new = x1 + delta[0];
const x2_new = x2 + delta[1];
const error = vectorNorm(delta);
...
if (error < epsilon) {
  convergenceCheck = "✅ Метод сходится - условие |Δx| < ε выполнено";
  ...
}
```

#### 2.2. Метод простой итерации для системы

Векторная схема простой итерации задаётся в виде
\[
  x^{(k+1)} = \Phi(x^{(k)}) = x^{(k)} - \omega B F(x^{(k)}),
\]
где \(B \approx J(x^{(0)})^{-1}\) — "замороженная" обратная Якоби, а \(\omega\) — параметр релаксации. В коде сначала вычисляется `B = inverse2x2(J0)`, затем определяется оператор \(\Phi\) и оценивается норма оператора \(\Phi'(x)\) в окрестности начального приближения через приближение
\[
  \Phi'(x) \approx I - \omega B J(x).
\]
Для этого используется вспомогательная функция `estimateSupNorm`, вычисляющая приближенную \(\sup\)-норму по сетке вокруг стартовой точки. Если \(\|\Phi'\| < 1\), делается вывод о локальной сходимости (в отчёте: `✅ sup||Φ'|| < 1 — локальная сходимость гарантирована`). Итерации продолжаются до выполнения критериев:
\[
  \max_i|x_i^{(k+1)}-x_i^{(k)}| \le \varepsilon,\quad \|F(x^{(k+1)})\| \le \varepsilon.
\]

#### 2.3. Метод Зейделя для системы

Для ускорения сходимости реализован метод Зейделя с использованием всё того же "замороженного" оператора \(B\), но с поочерёдным обновлением компонент:
\[
  \begin{aligned}
    x_1^{(k+1)} &= x_1^{(k)} - \omega \bigl(B_{11} F_1(x^{(k)}) + B_{12} F_2(x^{(k)})\bigr),\\
    x_2^{(k+1)} &= x_2^{(k)} - \omega \bigl(B_{21} F_1(x_1^{(k+1)}, x_2^{(k)}) + B_{22} F_2(x_1^{(k+1)}, x_2^{(k)})\bigr),
  \end{aligned}
\]
с поэлементной подстановкой "нового" \(x_1^{(k+1)}\) в правую часть второго уравнения. В коде это реализовано в `seidelStep`:

```313:323:2lab/2/numerical_methods.js
function seidelStep(xVec) {
  let Fv = [F1(xVec[0], xVec[1]), F2(xVec[0], xVec[1])];
  let B_F = multiplyMatrixVector(B, Fv);
  const x1_new = xVec[0] - omega * B_F[0];
  Fv = [F1(x1_new, xVec[1]), F2(x1_new, xVec[1])];
  B_F = multiplyMatrixVector(B, Fv);
  const x2_new = xVec[1] - omega * B_F[1];
  return [x1_new, x2_new];
}
```

Аналогично методу простой итерации, оценивается норма оператора и проверяется условие \(\sup\|\Phi'\|<1\) (локальная сходимость), после чего выполняется итерационный процесс до выполнения двойного критерия по шагу и невязке.

#### 2.4. Графический анализ системы и выбор начальных приближений

В `graph.js` для `2lab/2` реализовано:
- построение графиков эквивалентных функций:
  \[
    x_2 = \pm\sqrt{3 - x_1^2 + 2\cos x_1},\quad
    x_2 = e^{x_1^2-1} - 3;
  \]
- поиск точек пересечения этих кривых на заданном интервале по \(x_1\) с уточнением методом дихотомии;
- автоматическое заполнение начальных приближений \((x_1^{(0)}, x_2^{(0)})\) для всех численных методов.

Это обеспечивает визуальный анализ расположения корней системы и позволяет выбирать стартовые точки в областях, где методы Ньютона, простой итерации и Зейделя демонстрируют наилучшую сходимость. Сводная таблица (`createSummaryTable`) по аналогии с `2lab/1` сопоставляет результаты трёх методов по найденным корням, числу итераций и норме невязки \(\|F(x)\|\).

Таким образом, в рамках лабораторной №2 последовательно реализованы и проанализированы численные алгоритмы для **одномерных** и **системных** нелинейных задач, с акцентом на:
- строгие условия сходимости (знак производных, выпуклость, условие сжатия);
- роль выбора начальных приближений;
- сравнительный анализ скорости и устойчивости различных методов.


