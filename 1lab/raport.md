## Лабораторная работа 1  
**Численные методы решения систем линейных алгебраических уравнений и спектральной задачи**

В первой лабораторной работе реализуется и сопоставляется несколько ключевых алгоритмов линейной алгебры: прямые методы решения систем \(A x = b\) (метод Гаусса, LU‑разложение, метод прогонки для трёхдиагональных матриц) и итерационные методы (Якоби и Зейделя), а также QR‑алгоритм для нахождения собственных значений матрицы. Все реализации выполнены на языке JavaScript и сопровождаются диагностикой (печать матриц, проверка погрешностей, анализ сходимости).

### 1. Метод Гаусса, определитель и обратная матрица (`1.js`)

В файле `1.js` реализован класс `GaussMethod`, который решает систему линейных уравнений
\[
  A x = b,\quad A \in \mathbb{R}^{n\times n},\ b \in \mathbb{R}^n,
\]
методом Гаусса с прямым ходом и обратной подстановкой. Алгоритм формирует расширенную матрицу \([A|b]\) и поочерёдно зануляет элементы под диагональю:

```16:31:1lab/1.js
for (let i = 0; i < n; i++) {
  if (Math.abs(augmented[i][i]) < this.epsilon) {
    console.log("Матрица вырождена или система имеет бесконечно много решений");
    return null;
  }
  for (let k = i + 1; k < n; k++) {
    if (Math.abs(augmented[k][i]) > this.epsilon) {
      const factor = augmented[k][i] / augmented[i][i];
      for (let j = i; j < n + 1; j++) {
        augmented[k][j] -= factor * augmented[i][j];
      }
    }
  }
}
```

Далее выполняется обратный ход:
\[
  x_i = \frac{1}{a_{ii}}\Bigl(b_i - \sum_{j=i+1}^n a_{ij} x_j\Bigr),
\]
что реализовано циклом от \(i=n-1\) к \(0\). Класс также содержит методы:
- `determinant(A)` — вычисляет \(\det A\) с помощью треугольного преобразования и учёта перестановок строк;
- `inverseMatrix(A)` — строит обратную матрицу \(A^{-1}\), решая систему \([A|I] \to [I|A^{-1}]\).

В функции `solveSpecificSystem` задаётся конкретная система из 5 уравнений, печатается матрица коэффициентов и вектор правых частей, затем:
1. решается система методом Гаусса и проверяется погрешность в каждой строке;
2. вычисляется детерминант \(\det A\) и анализируется вырожденность;
3. строится обратная матрица \(A^{-1}\) и проверяется тождество \(A A^{-1} \approx I\);
4. дополнительно вычисляется решение как \(x = A^{-1} b\) и сравнивается с решением Гаусса.

### 2. LU‑разложение и решение СЛАУ (`2.js`)

Во втором задании (`2.js`) реализовано LU‑разложение матрицы \(A\) без явного выделения матриц \(L\) и \(U\). В функции `luInPlace` матрица \(A\) переписывается в виде \(A = L U\) по формулам:
\[
  u_{kj} = a_{kj} - \sum_{m=0}^{k-1} \ell_{km} u_{mj},\quad
  \ell_{ik} = \frac{1}{u_{kk}}\Bigl(a_{ik} - \sum_{m=0}^{k-1} \ell_{im} u_{mk}\Bigr).
\]
Это соответствует коду:

```47:64:1lab/2.js
for (let k = 0; k < n; k++) {
  for (let j = k; j < n; j++) {
    let sum = 0.0;
    for (let m = 0; m < k; m++) {
      sum += A[k][m] * A[m][j];
    }
    A[k][j] -= sum;          // элементы U
  }
  for (let i = k + 1; i < n; i++) {
    let sum = 0.0;
    for (let m = 0; m < k; m++) {
      sum += A[i][m] * A[m][k];
    }
    A[i][k] = (A[i][k] - sum) / A[k][k]; // элементы L
  }
}
```

Решение системы \(A x = b\) затем сводится к двум треугольным подзадачам:
\[
  L y = b,\quad U x = y,
\]
которые реализованы функциями `forwardSubstitutionInPlace` и `backwardSubstitutionInPlace`. Определитель матрицы находится как произведение диагональных элементов `U`:

```103:109:1lab/2.js
function determinantInPlace(A) {
  let det = 1.0;
  for (let i = 0; i < A.length; i++) {
    det *= A[i][i];
  }
  return det;
}
```

Обратная матрица \(A^{-1}\) строится как набор столбцов, каждый из которых получается решением системы \(A x^{(j)} = e_j\). В отчёт выводятся:
- вектор решения \(x\),
- \(\det A\),
- матрица \(A^{-1}\),
- произведение \(A A^{-1}\), иллюстрирующее приближение к единичной матрице.

### 3. Метод прогонки (Томаса) для трёхдиагональных систем (`3.js`)

Файл `3.js` реализует специализированный алгоритм Томаса для трёхдиагональных систем
\[
  a_i x_{i-1} + b_i x_i + c_i x_{i+1} = d_i,\quad i=0,\dots,n-1.
\]
Сначала проверяется, что матрица действительно трёхдиагональна (ненулевые элементы только на главной, верхней и нижней диагоналях). Затем исходная система приводится к рекуррентному виду
\[
  x_i = \alpha_i x_{i+1} + \beta_i,
\]
где коэффициенты \(\alpha_i, \beta_i\) (прогоночные коэффициенты) вычисляются на прямом ходе:

```54:71:1lab/3.js
for (let i = 1; i < n; i++) {
  const denom = b_diag[i] + a[i] * alpha[i-1];
  ...
  alpha[i] = -c[i] / denom;
  beta[i] = (b[i] - a[i] * beta[i-1]) / denom;
}
```

Обратный ход реализует формулы
\[
  x_{n-1} = \beta_{n-1},\quad x_i = \alpha_i x_{i+1} + \beta_i,
\]
что видно в коде:

```80:93:1lab/3.js
const x = new Array(n).fill(0);
x[n-1] = beta[n-1];
for (let i = n-2; i >= 0; i--) {
  x[i] = alpha[i] * x[i+1] + beta[i];
}
```

Дополнительно реализован расчёт \(\det A\) через модифицированный метод Гаусса. На тестовой системе из 8 уравнений демонстрируются особенности структуры трёхдиагональной матрицы, решение методом прогонки и вычисление детерминанта.

### 4. Итерационный метод Якоби (`4.js`)

В `4.js` реализован метод Якоби (метод простых итераций для СЛАУ):
\[
  x_i^{(k+1)} = \frac{1}{a_{ii}}\Bigl(b_i - \sum_{j\ne i} a_{ij} x_j^{(k)}\Bigr), \quad i=1,\dots,n.
\]
Функция `solveSystem` последовательно строит векторы \(x^{(k)}\), оценивая максимальную компонентную разность \(\max_i|x_i^{(k+1)}-x_i^{(k)}|\) и останавливаясь при достижении заданной точности:

```34:47:1lab/4.js
for (let i = 0; i < n; i++) {
  let sum = 0;
  for (let j = 0; j < n; j++) {
    if (i !== j) {
      sum += A[i][j] * x[j];
    }
  }
  xNew[i] = (b[i] - sum) / A[i][i];
}
...
maxError = 0;
for (let i = 0; i < n; i++) {
  const error = Math.abs(xNew[i] - x[i]);
  maxError = Math.max(maxError, error);
}
```

Метод сопровождается проверкой условий сходимости: `checkConvergence` анализирует диагональное преобладание по строкам и столбцам, вычисляя отношения
\[
  r_i = \frac{\sum_{j\ne i} |a_{ij}|}{|a_{ii}|}.
\]
Если \(\max_i r_i < 1\), то сходимость гарантирована, что подробно выводится в консоль с таблицей строк/столбцов. Дополнительно реализована перестановка строк `reorderForDiagonalDominance`, которая автоматически улучшает диагональное преобладание.

На тестовой системе \(4\times 4\) демонстрируется:
- перестановка строк для улучшения сходимости;
- проверка условия диагонального преобладания;
- собственно итерационный процесс (вывод вектора решения и максимальной погрешности на каждом шаге);
- оценка числа итераций до сходимости.

### 5. Метод Зейделя (Gauss–Seidel) (`5.js`)

Файл `5.js` реализует модификацию предыдущего подхода — метод Гаусса–Зейделя, в котором новое значение \(x_i^{(k+1)}\) немедленно используется при вычислении следующих компонент:
\[
  x_i^{(k+1)} = \frac{1}{a_{ii}}\Bigl(
    b_i - \sum_{j<i} a_{ij} x_j^{(k+1)} - \sum_{j>i} a_{ij} x_j^{(k)}
  \Bigr).
\]
Это отражено в двойном цикле:

```37:48:1lab/5.js
for (let i = 0; i < n; i++) {
  let sum = 0;
  for (let j = 0; j < i; j++) {
    sum += A[i][j] * x[j];      // уже обновлённые значения
  }
  for (let j = i + 1; j < n; j++) {
    sum += A[i][j] * x[j];      // старые значения
  }
  x[i] = (b[i] - sum) / A[i][i];
}
```

Так же, как и в методе Якоби, реализована проверка условий сходимости через диагональное преобладание и автоматическая перестановка строк. В отчёте по системе из Таблицы 3 приводятся:
- начальное и переставленное расположение строк;
- проверка \(\max_i r_i < 1\) по строкам и столбцам;
- динамика итерационной погрешности и итоговое решение \(x\) с числом итераций.

### 6. QR‑алгоритм для собственных значений (`6.js`)

В файле `6.js` реализован QR‑алгоритм для нахождения собственных значений матрицы \(A\) размерности \(5\times 5\). Исходная задача формулируется как
\[
  A v = \lambda v,
\]
а численный алгоритм выполняет последовательность разложений
\[
  A_k = Q_k R_k,\quad A_{k+1} = R_k Q_k,
\]
при этом матрица \(A_k\) постепенно приводится к верхней квазитреугольной форме. QR‑разложение производится с помощью отражений Хаусхолдера:

```79:118:1lab/6.js
for (let k = 0; k < n - 1; k++) {
  const x = [];
  for (let i = k; i < n; i++) {
    x.push(R[i][k]);
  }
  const normX = norm(x);
  const sign = x[0] < 0 ? -1.0 : 1.0;
  const v = [];
  v[0] = x[0] + sign * normX;
  for (let i = 1; i < x.length; i++) {
    v[i] = x[i];
  }
  const normV = norm(v);
  ...
  const H = identityMatrix(n);
  for (let i = k; i < n; i++) {
    for (let j = k; j < n; j++) {
      H[i][j] -= 2 * v[i - k] * v[j - k];
    }
  }
  R = multiplyMatrices(H, R);
  Q = multiplyMatrices(Q, H);
}
```

После достаточного числа итераций матрица \(A_k\) становится квазитреугольной: поддиагональные элементы вне возможных \(2\times2\) блоков близки к нулю (`isQuasiUpperTriangular`). Собственные значения извлекаются как:
- диагональные элементы (вещественные корни);
- собственные значения блоков \(2\times2\), полученные по классическим формулам:
\[
  \lambda_{1,2} = \frac{\operatorname{tr}(B) \pm \sqrt{\operatorname{tr}^2(B) - 4\det B}}{2},\quad
  B = \begin{pmatrix} a & b \\ c & d \end{pmatrix}.
\]
В коде это реализовано функцией `extractEigenvalues`, которая возвращает массив объектов `Complex`:

```141:163:1lab/6.js
const trace = a + d;
const det = a * d - b * c;
const discriminant = trace * trace - 4 * det;
if (discriminant >= 0) {
  const lambda1 = (trace + Math.sqrt(discriminant)) / 2;
  const lambda2 = (trace - Math.sqrt(discriminant)) / 2;
  eigenvalues.push(new Complex(lambda1, 0));
  eigenvalues.push(new Complex(lambda2, 0));
} else {
  const realPart = trace / 2;
  const imagPart = Math.sqrt(-discriminant) / 2;
  eigenvalues.push(new Complex(realPart, imagPart));
  eigenvalues.push(new Complex(realPart, -imagPart));
}
```

Итоговый отчёт по лабораторной демонстрирует, как различные прямые и итерационные методы применяются к конкретным задачам: решение СЛАУ, вычисление детерминанта и обратной матрицы, свойства трёхдиагональных систем и построение спектра матрицы с помощью QR‑алгоритма. На практике сравниваются точность, устойчивость и вычислительная сложность методов, а также проверяется корректность реализации через обратные подстановки и контрольные произведения (например, \(A A^{-1}\) и \(A v - \lambda v\) через полученные собственные значения).


